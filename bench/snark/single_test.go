package wts

import (
	"math/big"
	"math/rand"
	"testing"
	"time"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/hash"
	"github.com/consensys/gnark-crypto/signature/eddsa"
	"github.com/consensys/gnark/backend/groth16"
	"github.com/consensys/gnark/backend/plonk"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/r1cs"
	"github.com/consensys/gnark/frontend/cs/scs"
	"github.com/consensys/gnark/test"

	tedwards "github.com/consensys/gnark-crypto/ecc/twistededwards"
	"github.com/consensys/gnark/std/algebra/twistededwards"
	"github.com/consensys/gnark/std/hash/mimc"
)

// gnark is a zk-SNARK library written in Go. Circuits are regular structs.
// The inputs must be of type frontend.Variable and make up the witness.
// The witness has a
//   - secret part --> known to the prover only
//   - public part --> known to the prover and the verifier
type ECircuit struct {
	PublicKey PublicKey         `gnark:",public"`
	Signature Signature         `gnark:",public"`
	Message   frontend.Variable `gnark:",public"`
}

// Define declares the circuit logic. The compiler then produces a list of constraints
// which must be satisfied (valid witness) in order to create a valid zk-SNARK
// This circuit verifies an EdDSA signature.
func (circuit *ECircuit) Define(api frontend.API) error {
	// set the twisted edwards curve to use
	curve, err := twistededwards.NewEdCurve(api, tedwards.BN254)
	if err != nil {
		return err
	}

	// hash function
	mimc, err := mimc.NewMiMC(api)
	if err != nil {
		return err
	}

	// tip: gnark profiles enable circuit developers to measure the number of constraints
	// generated by a part of the (or the entire) circuit, using pprof.
	// see github.com/consensys/gnark/profile

	// tip: api.Println behaves like go fmt.Println but accepts frontend.Variable
	// that are resolved at Proving time
	// api.Println("message", circuit.Message)

	// verify the EdDSA signature
	return VerifyS(curve, circuit.Signature, circuit.Message, circuit.PublicKey, &mimc)
}

func TestEBasic(t *testing.T) {
	assert := test.NewAssert(t)

	type testData struct {
		hash  hash.Hash
		curve tedwards.ID
	}

	conf := testData{hash.MIMC_BN254, tedwards.BN254}
	snarkCurve := ecc.BN254

	seed := time.Now().Unix()
	// t.Logf("setting seed in rand %d", seed)
	randomness := rand.New(rand.NewSource(seed))

	// pick a message to sign
	snarkField, err := twistededwards.GetSnarkField(conf.curve)
	assert.NoError(err)
	var msg big.Int
	msg.Rand(randomness, snarkField)
	// t.Log("msg to sign", msg.String())
	msgData := msg.Bytes()

	var assignment ECircuit
	assignment.Message = msg

	privKey, err := eddsa.New(conf.curve, randomness)
	assert.NoError(err, "generating eddsa key pair")

	signature, err := privKey.Sign(msgData, conf.hash.New())
	assert.NoError(err, "signing message")

	pubKey := privKey.Public()

	checkSig, err := pubKey.Verify(signature, msgData[:], conf.hash.New())
	assert.NoError(err, "verifying signature")
	assert.True(checkSig, "signature verification failed")

	assignment.PublicKey.Assign(snarkCurve, pubKey.Bytes())
	assignment.Signature.Assign(snarkCurve, signature)

	// groth16 example here
	var gcircuit ECircuit
	ccs, _ := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &gcircuit)
	witness, _ := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())
	publicWitness, _ := witness.Public()

	pk, vk, _ := groth16.Setup(ccs)
	proof, _ := groth16.Prove(ccs, pk, witness)
	err = groth16.Verify(proof, vk, publicWitness)
	assert.NoError(err, "Successful verification")
}

func TestEBasicP(t *testing.T) {
	assert := test.NewAssert(t)

	type testData struct {
		hash  hash.Hash
		curve tedwards.ID
	}

	conf := testData{hash.MIMC_BN254, tedwards.BN254}
	snarkCurve := ecc.BN254

	seed := time.Now().Unix()
	randomness := rand.New(rand.NewSource(seed))

	// pick a message to sign
	snarkField, err := twistededwards.GetSnarkField(conf.curve)
	var msg big.Int
	msg.Rand(randomness, snarkField)
	msgData := msg.Bytes()

	var assignment ECircuit
	assignment.Message = msg

	privKey, err := eddsa.New(conf.curve, randomness)
	signature, err := privKey.Sign(msgData, conf.hash.New())

	pubKey := privKey.Public()

	checkSig, err := pubKey.Verify(signature, msgData[:], conf.hash.New())
	assert.True(checkSig, "signature verification failed")

	assignment.PublicKey.Assign(snarkCurve, pubKey.Bytes())
	assignment.Signature.Assign(snarkCurve, signature)

	// plonk example here
	var circuit ECircuit
	ccs, _ := frontend.Compile(ecc.BN254.ScalarField(), scs.NewBuilder, &circuit)
	witness, _ := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())
	publicWitness, _ := witness.Public()

	srs, err := test.NewKZGSRS(ccs)
	pk, vk, err := plonk.Setup(ccs, srs)
	correctProof, err := plonk.Prove(ccs, pk, witness)
	err = plonk.Verify(correctProof, vk, publicWitness)
	assert.NoError(err, "Successful verification")
}
